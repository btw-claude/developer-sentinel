# Example Orchestration Configuration
# ====================================
#
# This file demonstrates the complete orchestration configuration schema.
# Copy and modify this file to create your own orchestrations.
#
# Enable/Disable Flags:
# ---------------------
# Orchestrations can be disabled at two levels:
#
# 1. File-level: Add "enabled: false" at the root to disable ALL orchestrations
#    in the file. This takes precedence over individual orchestration settings.
#
# 2. Orchestration-level: Add "enabled: false" within any orchestration to
#    disable just that orchestration.
#
# Both default to true if not specified.
#
# Each orchestration defines:
#   - name: Unique identifier for the orchestration
#   - enabled: Whether this orchestration is active (optional, defaults to true)
#   - trigger: What Jira issues to watch for
#   - agent: How the Claude agent should process them
#   - retry: How to handle failures and determine success
#   - on_start: What to do when processing begins (prevents duplicate processing)
#   - on_complete: What to do after successful processing
#   - on_failure: What to do when all retries are exhausted
#
# Template Variables:
# -------------------
# The agent prompt supports template variables that are substituted with
# actual values from the Jira issue and GitHub context. Use these to give
# the agent exactly the context it needs:
#
# Jira Variables:
#   {jira_issue_key}    - Issue key (e.g., "PROJ-123")
#   {jira_summary}      - Issue title/summary
#   {jira_description}  - Full issue description
#   {jira_status}       - Current status (e.g., "In Progress")
#   {jira_assignee}     - Assignee display name
#   {jira_labels}       - Comma-separated labels
#   {jira_comments}     - Recent comments (last 3, formatted)
#   {jira_links}        - Comma-separated linked issue keys
#
# GitHub Variables:
#   {github_host}       - GitHub host (e.g., "github.com")
#   {github_org}        - Organization name
#   {github_repo}       - Repository name
#
# Branch Pattern Variables (available for branch patterns):
#   {jira_issue_key}       - e.g., "DS-290" -> branch: "feature/{jira_issue_key}"
#   {github_issue_number}  - e.g., "123" -> branch: "issue-{github_issue_number}"
#   Other variables from the executor (jira_summary, github_issue_title, etc.)
#   Note: Use {jira_issue_key} or {github_issue_number} for safe branch names
#
# Tag-based Workflow:
# -------------------
# Sentinel uses a stateless, tag-based workflow:
#   1. Issues with trigger tags are picked up for processing
#   2. Trigger tag is removed and in-progress tag is added (prevents duplicate processing)
#   3. On success: in-progress tag is removed, completion tag is added
#   4. On failure: in-progress tag is removed, failure tag is added
#
# This ensures issues are processed exactly once and failure states are visible.
#
# Enable/Disable Examples:
# ------------------------
# To disable the entire file:
#
#   enabled: false
#   orchestrations:
#     - name: "will-be-skipped"
#       ...
#
# To disable a specific orchestration:
#
#   orchestrations:
#     - name: "active-orchestration"
#       enabled: true  # Optional, this is the default
#       ...
#     - name: "disabled-orchestration"
#       enabled: false  # This orchestration will be skipped
#       ...
#
# Outcome-based Tags:
# -------------------
# For more nuanced workflows, you can define multiple success outcomes with
# different tags. For example, a code review might result in "approved" or
# "changes-requested", each adding a different label to the Jira issue.
# See the "code-review-with-outcomes" example below.

# File-level enable flag (optional, defaults to true)
# Uncomment to disable ALL orchestrations in this file:
# enabled: false

orchestrations:
  # Code Review Orchestration
  # -------------------------
  # Watches for Jira issues tagged with "needs-code-review" and
  # sends them to a Claude agent for code review.
  - name: "code-review"

    # Enable/disable this orchestration (optional, defaults to true)
    # Set to false to temporarily disable without removing the configuration
    enabled: true

    # Trigger configuration
    # Defines which Jira issues activate this orchestration
    trigger:
      source: jira              # Only "jira" is supported initially
      project: "PROJ"           # Jira project key to watch
      jql_filter: "status != Closed"  # Additional JQL filter (optional)
      tags:                     # Labels that trigger this orchestration
        - "needs-code-review"

    # Agent configuration
    # Defines the Claude agent's behavior
    agent:
      # Optional: Specify which Claude model to use
      # If not specified, uses the Claude CLI's default model
      # Full identifiers: claude-opus-4-5-20251101, claude-sonnet-4-20250514, claude-haiku-3-5-20241022
      # Shorthand (latest): opus, sonnet, haiku
      # model: "sonnet"

      # Optional: Specify which agent type to use
      # If not specified, defaults to SENTINEL_DEFAULT_AGENT_TYPE environment variable (defaults to "claude")
      # Valid values: "claude", "cursor"
      # agent_type: "claude"

      # Optional: Cursor-specific mode (only valid when agent_type is "cursor")
      # If not specified when agent_type is "cursor", defaults to SENTINEL_CURSOR_DEFAULT_MODE (defaults to "agent")
      # Valid values: "agent", "plan", "ask"
      # - agent: Full autonomous agent mode (default)
      # - plan: Planning mode - creates plans without executing
      # - ask: Ask mode - waits for user confirmation before actions
      # cursor_mode: "agent"

      # The prompt/instructions for the agent
      # Use template variables like {jira_issue_key} to include issue context
      prompt: |
        You are a code review assistant. Review issue {jira_issue_key}.

        ## Issue Details
        **Summary:** {jira_summary}
        **Status:** {jira_status}
        **Assignee:** {jira_assignee}

        **Description:**
        {jira_description}

        **Repository:** {github_org}/{github_repo}

        ## Your Task
        Review the code changes and provide feedback. Focus on:
        - Code correctness and potential bugs
        - Security vulnerabilities
        - Performance considerations
        - Code style and best practices

        Post your findings as a comment on the Jira issue.
        If there's a linked GitHub PR, also post a review there.

        End your response with SUCCESS if the review was completed, or
        FAILURE if you encountered issues.

      # Tools available to the agent
      # Options: jira, confluence, github
      tools:
        - jira
        - github

      # GitHub context (required if github tool is enabled)
      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"
        # Branch pattern support (optional):
        # branch: "feature/{jira_issue_key}"  # Pattern with template variables
        # create_branch: true                  # Create branch if it doesn't exist
        # base_branch: main                    # Base branch for new branches

    # Retry configuration
    # Defines how to handle agent failures
    retry:
      max_attempts: 3           # Maximum retry attempts

      # Patterns in agent response that indicate success
      success_patterns:
        - "SUCCESS"
        - "completed successfully"
        - "review complete"

      # Patterns in agent response that indicate failure
      # Note: Use specific patterns to avoid false positives (e.g., "error" could
      # match "No errors found" - use "ERROR:" or "TASK_FAILED" instead)
      # See docs/FAILURE_PATTERNS.md for detailed guidance on pattern selection.
      failure_patterns:
        - "FAILURE"
        - "TASK_FAILED"
        - "ERROR:"
        - "COULD_NOT_COMPLETE:"

    # On start actions
    # What to do immediately when an issue is picked up
    # This prevents duplicate processing if poll interval < processing time
    on_start:
      add_tag: "sentinel-processing"  # Automatically removed after processing

    # On complete actions
    # What to do after successful processing
    # Note: trigger tag is already removed when processing starts
    on_complete:
      add_tag: "code-reviewed"          # Add completion tag

    # On failure actions
    # What to do when all retry attempts are exhausted
    on_failure:
      add_tag: "review-failed"          # Add failure tag for investigation

  # Documentation Orchestration
  # ---------------------------
  # Example of a documentation-focused orchestration
  - name: "update-docs"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "needs-docs"

    agent:
      prompt: |
        You are a documentation assistant. Update documentation for {jira_issue_key}.

        ## Issue Details
        **Summary:** {jira_summary}

        **Description:**
        {jira_description}

        ## Your Task
        Based on the Jira issue above, update the relevant Confluence documentation.
        After updating, post a summary as a comment on the Jira issue.

        End your response with SUCCESS or FAILURE.

      tools:
        - jira
        - confluence

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
        - "documentation updated"
      # Use specific patterns - see docs/FAILURE_PATTERNS.md for guidance
      failure_patterns:
        - "FAILURE"
        - "TASK_FAILED"
        - "COULD_NOT_COMPLETE:"

    on_start:
      add_tag: "sentinel-processing"

    on_complete:
      add_tag: "docs-updated"

    on_failure:
      add_tag: "docs-update-failed"

  # Code Review with Outcomes
  # -------------------------
  # This example shows how to use outcomes for different success types.
  # Instead of a single success tag, different outcomes add different labels.
  - name: "code-review-with-outcomes"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "needs-code-review"

    agent:
      prompt: |
        You are a code review assistant. Review {jira_issue_key}: {jira_summary}

        ## Issue Description
        {jira_description}

        ## Repository
        {github_org}/{github_repo}

        ## Your Task
        Review the code changes in the linked GitHub PR and provide feedback.

        After reviewing:
        - If the code looks good, end with "APPROVED: [brief summary]"
        - If changes are needed, end with "CHANGES REQUESTED: [what needs to change]"

        Always post your review comments on the GitHub PR.

      tools:
        - jira
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"

      # Optional timeout in seconds (5 minutes)
      timeout_seconds: 300

    # Retry configuration
    # failure_patterns trigger retries for actual errors (API failures, etc.)
    # Use specific patterns - see docs/FAILURE_PATTERNS.md for guidance
    retry:
      max_attempts: 3
      failure_patterns:
        - "ERROR:"
        - "API_ERROR"
        - "CONNECTION_TIMEOUT"
        - "COULD_NOT_COMPLETE:"
      # default_outcome is used when no outcome patterns match (optional)
      # If not specified or set to "failure", triggers the failure/retry mechanism
      # If set to an outcome name (e.g., "approved"), uses that outcome on no match
      default_outcome: "approved"

    # Outcomes define different success types with different tags
    # Each outcome has:
    #   - name: identifier for the outcome
    #   - patterns: strings that indicate this outcome (case-insensitive)
    #               Use "regex:" prefix for regex patterns
    #   - add_tag: label to add when this outcome is matched
    outcomes:
      - name: approved
        patterns:
          - "APPROVED"
          - "LGTM"
          - "looks good"
        add_tag: "code-reviewed"

      - name: changes-requested
        patterns:
          - "CHANGES REQUESTED"
          - "REQUEST CHANGES"
          - "needs changes"
        add_tag: "changes-requested"

    on_start:
      add_tag: "sentinel-processing"

    # on_complete is not needed when using outcomes - the outcome's add_tag
    # is used instead. on_complete is a fallback for backwards compatibility.

    on_failure:
      add_tag: "review-failed"

  # GitHub Project-Based Trigger
  # ----------------------------
  # This example shows how to use GitHub Projects (v2) as a trigger source.
  # Instead of polling Jira, this orchestration polls a GitHub Project board
  # and processes items matching the filter criteria.
  - name: "github-project-code-review"

    trigger:
      source: github              # Use GitHub as the trigger source

      # GitHub Project Configuration (required for GitHub triggers)
      # ----------------------------------------------------------
      # project_number: The project number from the GitHub project URL
      #   e.g., https://github.com/orgs/your-org/projects/42 -> project_number: 42
      project_number: 42

      # project_owner: The organization or user that owns the project
      project_owner: "your-org"

      # project_scope: Either "org" (organization project) or "user" (personal project)
      project_scope: "org"

      # project_filter: JQL-like filter expression to select items from the project
      # Supports:
      #   - Equality: Status = "Ready for Review"
      #   - Inequality: Status != "Done"
      #   - AND/OR: Status = "Ready" AND Priority = "High"
      #   - Parentheses: (Status = "Ready" OR Status = "In Progress") AND Priority = "High"
      # Field names must match the project's custom fields exactly (case-sensitive)
      project_filter: 'Status = "Ready for Review"'

      # labels: List of GitHub labels to filter by (optional)
      # ----------------------------------------------------------
      # - Issues/PRs must have ALL specified labels to match (AND logic)
      # - Label matching is case-insensitive ("Bug" matches "bug", "BUG", etc.)
      # - Can be combined with project_filter for more precise filtering
      # - Similar to Jira's tags field, but for GitHub issues/PRs
      # labels:
      #   - "needs-review"
      #   - "priority-high"

    agent:
      prompt: |
        You are a code review assistant processing GitHub issues and PRs from a project board.

        ## Your Task
        1. Fetch the issue/PR details from GitHub
        2. Review any associated code changes
        3. Post review comments on the PR
        4. Update the project item status

        End your response with:
        - "APPROVED: [summary]" if the code looks good
        - "CHANGES REQUESTED: [what to fix]" if changes are needed
        - "FAILURE: [reason]" if you couldn't complete the review

      tools:
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"  # Default repo for cloning operations

      timeout_seconds: 600  # 10 minutes for complex reviews

    retry:
      max_attempts: 3
      # Use specific patterns - see docs/FAILURE_PATTERNS.md for guidance
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "API_ERROR"
        - "COULD_NOT_COMPLETE:"

    outcomes:
      - name: approved
        patterns:
          - "APPROVED"
          - "LGTM"
        add_tag: "reviewed"  # GitHub label to add

      - name: changes-requested
        patterns:
          - "CHANGES REQUESTED"
          - "needs changes"
        add_tag: "changes-requested"

    on_start:
      add_tag: "sentinel-processing"

    on_failure:
      add_tag: "review-failed"

  # GitHub Project with Labels Filtering
  # -------------------------------------
  # This example demonstrates using the labels field to filter GitHub issues/PRs
  # by their labels. Labels can be combined with project_filter for precise filtering.
  - name: "github-labeled-bug-review"

    trigger:
      source: github
      project_number: 42
      project_owner: "your-org"
      project_scope: "org"

      # Filter by GitHub labels (issues must have ALL specified labels - AND logic)
      # Label matching is case-insensitive ("Bug" matches "bug", "BUG", etc.)
      labels:
        - "bug"
        - "needs-triage"

      # Can combine labels with project_filter for more precise filtering
      # This will match items that:
      # 1. Have BOTH "bug" AND "needs-triage" labels
      # 2. AND have Status = "Ready" in the project board
      project_filter: 'Status = "Ready"'

    agent:
      prompt: |
        You are a bug triage assistant. Review and triage the bug.

        The issue has been pre-filtered to include only items with both
        "bug" and "needs-triage" labels. Analyze the bug report and:
        1. Verify it's a valid bug (not a feature request or user error)
        2. Assess severity and priority
        3. Add appropriate labels (severity, component, etc.)
        4. Assign to the appropriate team member if possible

        End with SUCCESS when triage is complete.

      tools:
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
        - "triage complete"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "TASK_FAILED"

    on_start:
      add_tag: "sentinel-triaging"

    on_complete:
      add_tag: "triaged"

    on_failure:
      add_tag: "triage-failed"

  # GitHub Project with Multiple Repository Support
  # -----------------------------------------------
  # GitHub Projects (v2) can contain issues and PRs from multiple repositories.
  # Sentinel automatically extracts the correct repository context from each
  # item's URL, enabling operations across different repos in a single project.
  - name: "github-cross-repo-triage"

    trigger:
      source: github
      project_number: 10
      project_owner: "your-org"
      project_scope: "org"
      # Process items in "Needs Triage" status from any repo in the project
      project_filter: 'Status = "Needs Triage"'

    agent:
      prompt: |
        You are a triage assistant. For each issue/PR:
        1. Read the issue description and labels
        2. Determine the appropriate priority and assignee
        3. Add relevant labels
        4. Move the item to the appropriate status

        The item may be from any repository in the project - the system will
        automatically handle the correct repository context for GitHub operations.

        End with SUCCESS when triage is complete.

      tools:
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "default-repo"  # Default repo (actual repo extracted from each item)

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
        - "triage complete"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "TASK_FAILED"

    on_start:
      add_tag: "sentinel-triaging"

    on_complete:
      add_tag: "triaged"

    on_failure:
      add_tag: "triage-failed"

  # Cursor Agent Example
  # --------------------
  # This example demonstrates using Cursor as the agent type instead of Claude.
  # The agent_type and cursor_mode fields allow you to use Cursor's AI capabilities
  # for tasks that benefit from its IDE integration.
  - name: "cursor-code-review"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "cursor-review"

    agent:
      # Use Cursor instead of Claude for this orchestration
      agent_type: cursor

      # Cursor mode: "agent" (autonomous), "plan" (planning only), "ask" (confirmation required)
      cursor_mode: agent

      prompt: |
        You are a code review assistant running in Cursor. Review issue {jira_issue_key}.

        ## Issue Details
        **Summary:** {jira_summary}

        **Description:**
        {jira_description}

        ## Repository
        {github_org}/{github_repo}

        ## Your Task
        Review the code changes and provide feedback. Use Cursor's code understanding
        capabilities to analyze the codebase context.

        Post your findings as a comment on the Jira issue.

        End your response with SUCCESS or FAILURE.

      tools:
        - jira
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"

      timeout_seconds: 600

    retry:
      max_attempts: 3
      success_patterns:
        - "SUCCESS"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "TASK_FAILED"

    on_start:
      add_tag: "cursor-processing"

    on_complete:
      add_tag: "cursor-reviewed"

    on_failure:
      add_tag: "cursor-review-failed"

  # Cursor Planning Mode Example
  # ----------------------------
  # This example shows using Cursor in "plan" mode, which creates implementation
  # plans without executing them. Useful for complex refactoring tasks that need
  # human review before execution.
  - name: "cursor-refactor-planner"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "needs-refactor-plan"

    agent:
      agent_type: cursor
      cursor_mode: plan  # Planning mode - creates plans without executing

      prompt: |
        You are a refactoring planner. Create an implementation plan for {jira_issue_key}.

        ## Issue Details
        **Summary:** {jira_summary}

        **Description:**
        {jira_description}

        ## Your Task
        Analyze the codebase and create a detailed refactoring plan that includes:
        1. Files that need to be modified
        2. Specific changes for each file
        3. Potential risks and how to mitigate them
        4. Suggested order of operations

        Post the plan as a comment on the Jira issue for review.

        End with SUCCESS after posting the plan.

      tools:
        - jira
        - github

      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "TASK_FAILED"

    on_start:
      add_tag: "planning-refactor"

    on_complete:
      add_tag: "refactor-plan-ready"

    on_failure:
      add_tag: "planning-failed"

  # Feature Development with Branch Patterns
  # ----------------------------------------
  # This example demonstrates using branch patterns to automatically create
  # feature branches for each Jira issue. The agent will work on a dedicated
  # branch, making it easy to create pull requests afterward.
  - name: "feature-development"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "ready-for-dev"

    agent:
      prompt: |
        You are a development assistant. Implement the feature for {jira_issue_key}.

        ## Issue Details
        **Summary:** {jira_summary}

        **Description:**
        {jira_description}

        ## Repository
        You are working on branch: feature/{jira_issue_key}
        Repository: {github_org}/{github_repo}

        ## Your Task
        1. Implement the feature as described in the issue
        2. Write appropriate tests
        3. Commit your changes with clear commit messages
        4. Update the Jira issue with a summary of what was implemented

        End with SUCCESS when the feature is implemented, or FAILURE if blocked.

      tools:
        - jira
        - github

      # GitHub context with branch pattern
      # -----------------------------------
      # The branch field supports template variables that are expanded at runtime.
      # Available variables:
      #   {jira_issue_key}       - e.g., "DS-290" -> creates "feature/DS-290"
      #   {github_issue_number}  - e.g., "123" -> creates "feature/123"
      #
      # Branch behavior:
      #   - Branch checkout happens BEFORE the agent runs
      #   - create_branch: true  -> Creates branch from base_branch if not exists
      #   - create_branch: false -> Fails if branch doesn't exist (default)
      #   - No branch specified  -> Uses repository's default branch
      github:
        host: "github.com"
        org: "your-org"
        repo: "your-repo"
        branch: "feature/{jira_issue_key}"  # Creates e.g., feature/PROJ-123
        create_branch: true                  # Auto-create if doesn't exist
        base_branch: main                    # Create from main branch

      timeout_seconds: 900  # 15 minutes for feature implementation

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
        - "feature implemented"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"
        - "BLOCKED:"

    on_start:
      add_tag: "sentinel-implementing"

    on_complete:
      add_tag: "feature-implemented"

    on_failure:
      add_tag: "implementation-failed"

  # Fork Workflow with Branch Patterns
  # ----------------------------------
  # This example demonstrates working with forks. The org is set to your
  # personal account (the fork), while the agent can still reference the
  # upstream repository context in its work.
  - name: "fork-feature-development"

    trigger:
      source: jira
      project: "PROJ"
      tags:
        - "fork-dev"

    agent:
      prompt: |
        You are a development assistant working on a fork.

        ## Issue Details
        **Issue:** {jira_issue_key} - {jira_summary}

        **Description:**
        {jira_description}

        ## Repository
        Working on fork: {github_org}/{github_repo}
        Branch: feature/{jira_issue_key}

        ## Your Task
        1. Implement the feature on your fork branch
        2. Commit changes with clear messages
        3. The branch can later be used to create a PR to upstream

        End with SUCCESS when complete.

      tools:
        - jira
        - github

      # Fork workflow: org points to your fork (personal account)
      # The agent will clone and work on your fork, creating branches there.
      # You can then create pull requests from your fork to the upstream repo.
      github:
        host: "github.com"
        org: "my-username"           # Your GitHub username (fork owner)
        repo: "project-name"          # Repository name (same as upstream)
        branch: "feature/{jira_issue_key}"
        create_branch: true
        base_branch: main

    retry:
      max_attempts: 2
      success_patterns:
        - "SUCCESS"
      failure_patterns:
        - "FAILURE"
        - "ERROR:"

    on_start:
      add_tag: "fork-processing"

    on_complete:
      add_tag: "fork-ready-for-pr"

    on_failure:
      add_tag: "fork-failed"
