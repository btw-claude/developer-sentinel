{# Security audit complete - no external links (target="_blank") in this template #}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Developer Sentinel Dashboard{% endblock %}</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <link rel="stylesheet" href="/static/css/utilities.css">
    <style>
        :root {
            /* Base theme colors (alphabetized for maintainability) */
            --accent: #0f3460;
            --accent-hover: rgba(15, 52, 96, 0.3);
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --danger: #e63946;
            --success: #00d26a;
            --text-primary: #eee;
            --text-secondary: #aaa;
            --warning: #f9c74f;

            /* Accordion component custom properties (alphabetized) */
            --accordion-border: var(--accent);
            --accordion-content-bg: var(--bg-primary);
            --accordion-header-bg: var(--bg-secondary);
            --accordion-header-hover: var(--accent);
            --accordion-hover: var(--accent-hover);
            --accordion-radius: 0.25rem;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        header {
            background-color: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--accent);
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        nav a {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--text-primary);
            background-color: var(--accent);
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .card {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--accent);
        }

        .card h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .metric {
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: var(--accent);
            border-radius: 4px;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .status-ok { color: var(--success); }
        .status-warn { color: var(--warning); }
        .status-error { color: var(--danger); }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid var(--accent);
        }

        th {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.875rem;
            text-transform: uppercase;
        }

        .tag {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            background-color: var(--accent);
            border-radius: 4px;
            font-size: 0.75rem;
            margin-right: 0.25rem;
        }

        /* Collapsible section styles */
        .collapsible-section {
            padding: 0;
        }

        .collapsible-header {
            padding: 1rem 1.5rem;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }

        .collapsible-header:hover {
            background-color: var(--accent);
        }

        .collapsible-header h2 {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .collapse-icon {
            font-size: 0.75rem;
            transition: transform 0.2s;
            display: inline-block;
        }

        .collapse-icon.rotated {
            transform: rotate(90deg);
        }

        .badge {
            background-color: var(--accent);
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: normal;
            color: var(--text-secondary);
            margin-left: auto;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 1.5rem;
        }

        .collapsible-content.expanded {
            /* CSS transitions cannot animate to 'auto' height, so we use a fixed
               max-height value large enough to accommodate the content. This is a
               known CSS limitation - the value must be larger than any expected
               content height for the animation to work smoothly. */
            max-height: 2000px;
            padding: 0 1.5rem 1.5rem 1.5rem;
        }

        /* Source badge styles */
        .source-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .source-badge.jira {
            background-color: #0052cc;
            color: white;
        }

        .source-badge.github {
            background-color: #238636;
            color: white;
        }

    </style>
    <script>
        /**
         * Centralized CSS fallback color constants for cross-browser compatibility.
         * These fallback values are used when CSS custom properties are not supported.
         * Matches the CSS custom properties defined in :root for consistency.
         * Added Object.freeze() for defensive programming best practices.
         * @constant {Object}
         */
        const CSS_FALLBACK_COLORS = Object.freeze({
            danger: '#e63946',
            success: '#00d26a',
            warning: '#f9c74f',
            textPrimary: '#ffffff'
        });

        /**
         * Toggle a collapsible section's expanded state.
         * Handles both the visual toggle (icon rotation, content expansion)
         * and works with HTMX's lazy loading pattern.
         * Added defensive null checks for consistency with toggleNestedAccordion.
         * @param {HTMLElement} headerElement - The .collapsible-header element that was clicked
         */
        function toggleCollapsibleSection(headerElement) {
            const section = headerElement.closest('.collapsible-section');
            if (!section) {
                console.warn('toggleCollapsibleSection: Could not find parent .collapsible-section');
                return;
            }

            const content = section.querySelector('.collapsible-content');
            if (!content) {
                console.warn('toggleCollapsibleSection: Could not find .collapsible-content within section');
                return;
            }

            const icon = headerElement.querySelector('.collapse-icon');
            if (!icon) {
                console.warn('toggleCollapsibleSection: Could not find .collapse-icon within header');
                return;
            }

            content.classList.toggle('expanded');
            icon.classList.toggle('rotated');
        }

        /**
         * Toggle a nested accordion item's expanded state.
         * Used for project/repo groupings within orchestrations sections.
         * Added defensive null check to prevent errors when element not found.
         * @param {HTMLElement} headerElement - The .nested-accordion-header element that was clicked
         */
        function toggleNestedAccordion(headerElement) {
            const item = headerElement.closest('.nested-accordion-item');
            if (!item) {
                console.warn('toggleNestedAccordion: Could not find parent .nested-accordion-item');
                return;
            }
            item.classList.toggle('expanded');
        }

        /**
         * Toggle an orchestration detail row's expanded state.
         * Used for inline expansion of orchestration configuration details.
         * On first expansion, the HTMX hx-trigger="revealed" will load the detail content.
         * On second click, the detail row collapses.
         * @param {HTMLElement} rowElement - The clickable orchestration table row
         * @param {string} orchName - The orchestration name used to find the detail row
         */
        function toggleOrchestrationDetail(rowElement, orchName) {
            const detailRow = document.getElementById('detail-row-' + orchName);
            if (!detailRow) {
                console.warn('toggleOrchestrationDetail: Could not find detail row for: ' + orchName);
                return;
            }
            const isExpanded = detailRow.classList.contains('expanded');
            detailRow.classList.toggle('expanded');
            rowElement.setAttribute('aria-expanded', !isExpanded);
        }

        /**
         * Check if a collapsible section is expanded.
         * Used in HTMX trigger expressions for conditional auto-refresh.
         * @param {string} contentId - The ID of the collapsible content element (e.g., 'system-status-content')
         * @returns {boolean} True if the section is expanded, false otherwise
         */
        function isExpanded(contentId) {
            const element = document.querySelector('#' + contentId);
            if (!element) {
                console.warn('isExpanded: Element not found: ' + contentId);
                return false;
            }
            return element.classList.contains('expanded');
        }

        /**
         * Handle collapsible section click with propagation control.
         * Encapsulates the collapse-with-propagation-stop logic for reusability.
         * Only toggles and stops propagation if the section is already expanded,
         * allowing HTMX to handle the initial expansion via lazy loading.
         * Refactored to use data-collapsible-target attribute instead of inline onclick.
         * @param {HTMLElement} element - The header element that was clicked
         * @param {string} contentId - The ID of the collapsible content element
         * @param {Event} event - The click event
         */
        function handleCollapsibleClick(element, contentId, event) {
            if (isExpanded(contentId)) {
                toggleCollapsibleSection(element);
                event.stopImmediatePropagation();
            }
        }

        /**
         * Initialize collapsible section event listeners using event delegation.
         * Uses a single event listener on the main container instead of attaching
         * individual listeners to each collapsible header.
         * Refactored to use event delegation pattern for improved performance
         * and automatic support for dynamically added collapsible sections.
         * Benefits:
         * - Reduced memory usage with fewer event listeners
         * - Automatically handles dynamically added collapsible sections
         * - Single point of attachment for easier debugging
         */
        function initCollapsibleSections() {
            const mainContainer = document.querySelector('main');
            if (!mainContainer) {
                console.warn('initCollapsibleSections: Could not find main container for event delegation');
                return;
            }

            mainContainer.addEventListener('click', function(event) {
                // Find the closest element with data-collapsible-target attribute
                const header = event.target.closest('[data-collapsible-target]');
                if (!header) {
                    return; // Click was not on a collapsible header
                }

                const contentId = header.getAttribute('data-collapsible-target');
                handleCollapsibleClick(header, contentId, event);
            });
        }

        // Initialize collapsible sections when DOM is ready
        document.addEventListener('DOMContentLoaded', initCollapsibleSections);

        /**
         * Handle toggle API response with optimistic updates and error handling.
         * Reverts checkbox state on failure and updates status text on success.
         * Added try/catch for JSON.parse, null check for closest('td'),
         * success toast notification, and improved error handling.
         * @param {Event} event - The HTMX event containing the XHR response
         */
        function handleToggleResponse(event) {
            const response = event.detail.xhr.response;

            // Wrap JSON.parse in try/catch for graceful error handling of malformed JSON
            let data;
            try {
                data = JSON.parse(response);
            } catch (parseError) {
                console.error('handleToggleResponse: Failed to parse JSON response:', parseError);
                // Revert checkbox state on parse error
                event.target.checked = !event.target.checked;
                showToast('error', 'Failed to process server response');
                return;
            }

            if (!data.success) {
                // Revert checkbox state
                event.target.checked = !event.target.checked;
                // Show error toast/notification
                showToast('error', data.message || 'Toggle operation failed');
            } else {
                // Add null check for event.target.closest('td') to prevent potential errors
                const parentCell = event.target.closest('td');
                if (parentCell) {
                    // Update status text if present
                    const statusText = parentCell.querySelector('.status-text');
                    if (statusText) {
                        statusText.textContent = data.enabled ? 'Enabled' : 'Disabled';
                        statusText.className = 'status-text ' + (data.enabled ? 'status-ok' : 'status-warn');
                    }
                }
                // Add success toast notification for positive user feedback
                const statusMessage = data.enabled ? 'Enabled' : 'Disabled';
                showToast('success', 'Orchestration ' + statusMessage.toLowerCase() + ' successfully');
            }
        }

        /**
         * Handle delete API response with toast notification and list refresh.
         * Shows success or error toast and refreshes the orchestrations list on success.
         * @param {Event} event - The HTMX event containing the XHR response
         * @param {string} name - The name of the orchestration that was deleted
         */
        function handleDeleteResponse(event, name) {
            const xhr = event.detail.xhr;
            const status = xhr.status;

            if (status >= 200 && status < 300) {
                let data;
                try {
                    data = JSON.parse(xhr.response);
                } catch (parseError) {
                    console.error('handleDeleteResponse: Failed to parse JSON response:', parseError);
                    showToast('error', 'Failed to process server response');
                    return;
                }

                if (data.success) {
                    showToast('success', 'Orchestration \'' + name + '\' deleted successfully');
                    // Refresh the orchestrations list by triggering HTMX on the partials
                    htmx.trigger(document.body, 'orchestration-deleted');
                    // Also trigger a page-level refresh of orchestrations partial if present
                    const orchPartial = document.querySelector('[hx-get*="/partials/orchestrations"]');
                    if (orchPartial) {
                        htmx.trigger(orchPartial, 'revealed');
                    }
                } else {
                    showToast('error', 'Failed to delete orchestration \'' + name + '\'');
                }
            } else if (status === 429) {
                showToast('warning', 'Rate limit exceeded. Please wait before trying again.');
            } else {
                let errorMessage = 'Failed to delete orchestration \'' + name + '\'';
                try {
                    const errorData = JSON.parse(xhr.response);
                    if (errorData.detail) {
                        errorMessage = errorData.detail;
                    }
                } catch (e) {
                    // Use default error message
                }
                showToast('error', errorMessage);
            }
        }

        /**
         * Display a toast notification for user feedback.
         * Creates a temporary notification that auto-dismisses after a duration.
         * Added CSS variable fallbacks for better cross-browser compatibility.
         * @param {string} type - The notification type: 'error', 'success', or 'warning'
         * @param {string} message - The message to display
         * @param {number} [duration=5000] - How long to show the toast in milliseconds
         */
        function showToast(type, message, duration = 5000) {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.cssText = 'position: fixed; top: 1rem; right: 1rem; z-index: 9999; display: flex; flex-direction: column; gap: 0.5rem;';
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'toast toast-' + type;

            // Set colors based on type with CSS variable fallbacks for cross-browser compatibility
            // Refactored to use centralized CSS_FALLBACK_COLORS constants
            const colors = {
                error: 'var(--danger, ' + CSS_FALLBACK_COLORS.danger + ')',
                success: 'var(--success, ' + CSS_FALLBACK_COLORS.success + ')',
                warning: 'var(--warning, ' + CSS_FALLBACK_COLORS.warning + ')'
            };
            const bgColor = colors[type] || colors.error;

            // Added fallback values for CSS variables using centralized constants
            toast.style.cssText = 'background-color: ' + bgColor + '; color: var(--text-primary, ' + CSS_FALLBACK_COLORS.textPrimary + '); padding: 0.75rem 1rem; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); max-width: 300px; animation: slideIn 0.3s ease-out;';
            toast.textContent = message;

            // Add slide-in animation if not already defined
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = '@keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }';
                document.head.appendChild(style);
            }

            toastContainer.appendChild(toast);

            // Auto-remove after duration
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-in forwards';
                setTimeout(() => {
                    toast.remove();
                    // Remove container if empty
                    if (toastContainer.children.length === 0) {
                        toastContainer.remove();
                    }
                }, 300);
            }, duration);
        }
        /**
         * Submit an orchestration edit form via the PUT API endpoint.
         * Collects form fields, builds nested JSON matching OrchestrationEditRequest,
         * and submits via htmx.ajax('PUT', ...). Shows toast on result.
         * @param {HTMLFormElement} formElement - The form element to collect data from
         * @param {string} name - The orchestration name to update
         */
        function submitOrchestrationEdit(formElement, name) {
            if (!formElement) {
                console.error('submitOrchestrationEdit: formElement is null');
                return;
            }

            // Helper to split comma-separated or newline-separated values into an array
            function splitList(value, separator) {
                if (!value || !value.trim()) return [];
                var sep = separator || ',';
                return value.split(sep === '\n' ? /\r?\n/ : sep)
                    .map(function(s) { return s.trim(); })
                    .filter(function(s) { return s.length > 0; });
            }

            // Build the trigger section
            var triggerSource = formElement.querySelector('input[name="trigger_source"]:checked');
            var trigger = {};
            if (triggerSource) {
                trigger.source = triggerSource.value;
                if (triggerSource.value === 'jira') {
                    var project = formElement.querySelector('#jira_project');
                    if (project && project.value.trim()) trigger.project = project.value.trim();
                    var jqlFilter = formElement.querySelector('#jira_jql_filter');
                    if (jqlFilter && jqlFilter.value.trim()) trigger.jql_filter = jqlFilter.value.trim();
                    var tags = formElement.querySelector('#jira_tags');
                    if (tags && tags.value.trim()) trigger.tags = splitList(tags.value);
                } else {
                    var projNum = formElement.querySelector('#github_project_number');
                    if (projNum && projNum.value) trigger.project_number = parseInt(projNum.value, 10);
                    var projScope = formElement.querySelector('input[name="github_project_scope"]:checked');
                    if (projScope) trigger.project_scope = projScope.value;
                    var projOwner = formElement.querySelector('#github_project_owner');
                    if (projOwner && projOwner.value.trim()) trigger.project_owner = projOwner.value.trim();
                    var projFilter = formElement.querySelector('#github_project_filter');
                    if (projFilter && projFilter.value.trim()) trigger.project_filter = projFilter.value.trim();
                    var labels = formElement.querySelector('#github_labels');
                    if (labels && labels.value.trim()) trigger.labels = splitList(labels.value);
                }
            }

            // Build the agent section
            var agent = {};
            var agentType = formElement.querySelector('#agent_type');
            if (agentType && agentType.value) agent.agent_type = agentType.value;
            var cursorMode = formElement.querySelector('#cursor_mode');
            if (cursorMode && agentType && agentType.value === 'cursor') {
                agent.cursor_mode = cursorMode.value;
            }
            var model = formElement.querySelector('#model');
            if (model && model.value.trim()) agent.model = model.value.trim();
            var timeout = formElement.querySelector('#timeout_seconds');
            if (timeout && timeout.value) agent.timeout_seconds = parseInt(timeout.value, 10);
            var prompt = formElement.querySelector('#prompt');
            if (prompt) agent.prompt = prompt.value;

            // Build GitHub context sub-object
            var ghHost = formElement.querySelector('#github_host');
            var ghOrg = formElement.querySelector('#github_org');
            var ghRepo = formElement.querySelector('#github_repo');
            var ghBranch = formElement.querySelector('#github_branch');
            var ghCreateBranch = formElement.querySelector('#github_create_branch');
            var ghBaseBranch = formElement.querySelector('#github_base_branch');
            var github = {};
            var hasGithub = false;
            if (ghHost && ghHost.value.trim()) { github.host = ghHost.value.trim(); hasGithub = true; }
            if (ghOrg && ghOrg.value.trim()) { github.org = ghOrg.value.trim(); hasGithub = true; }
            if (ghRepo && ghRepo.value.trim()) { github.repo = ghRepo.value.trim(); hasGithub = true; }
            if (ghBranch && ghBranch.value.trim()) { github.branch = ghBranch.value.trim(); hasGithub = true; }
            if (ghCreateBranch) { github.create_branch = ghCreateBranch.checked; hasGithub = true; }
            if (ghBaseBranch && ghBaseBranch.value.trim()) { github.base_branch = ghBaseBranch.value.trim(); hasGithub = true; }
            if (hasGithub) agent.github = github;

            // Build the retry section
            var retry = {};
            var maxAttempts = formElement.querySelector('#max_attempts');
            if (maxAttempts && maxAttempts.value) retry.max_attempts = parseInt(maxAttempts.value, 10);
            var successPatterns = formElement.querySelector('#success_patterns');
            if (successPatterns && successPatterns.value.trim()) retry.success_patterns = splitList(successPatterns.value, '\n');
            var failurePatterns = formElement.querySelector('#failure_patterns');
            if (failurePatterns && failurePatterns.value.trim()) retry.failure_patterns = splitList(failurePatterns.value, '\n');
            var defaultStatus = formElement.querySelector('input[name="default_status"]:checked');
            if (defaultStatus) retry.default_status = defaultStatus.value;
            var defaultOutcome = formElement.querySelector('#default_outcome');
            if (defaultOutcome && defaultOutcome.value.trim()) retry.default_outcome = defaultOutcome.value.trim();

            // Build the outcomes section
            var outcomeRows = formElement.querySelectorAll('.outcome-row');
            var outcomes = [];
            outcomeRows.forEach(function(row) {
                var outName = row.querySelector('input[name="outcome_name"]');
                var outPatterns = row.querySelector('textarea[name="outcome_patterns"]');
                var outAddTag = row.querySelector('input[name="outcome_add_tag"]');
                if (outName && outName.value.trim()) {
                    var outcome = { name: outName.value.trim() };
                    if (outPatterns && outPatterns.value.trim()) outcome.patterns = splitList(outPatterns.value, '\n');
                    if (outAddTag && outAddTag.value.trim()) outcome.add_tag = outAddTag.value.trim();
                    outcomes.push(outcome);
                }
            });

            // Build the lifecycle section
            var lifecycle = {};
            var onStartAddTag = formElement.querySelector('#on_start_add_tag');
            if (onStartAddTag && onStartAddTag.value.trim()) lifecycle.on_start_add_tag = onStartAddTag.value.trim();
            var onCompleteRemoveTag = formElement.querySelector('#on_complete_remove_tag');
            if (onCompleteRemoveTag && onCompleteRemoveTag.value.trim()) lifecycle.on_complete_remove_tag = onCompleteRemoveTag.value.trim();
            var onCompleteAddTag = formElement.querySelector('#on_complete_add_tag');
            if (onCompleteAddTag && onCompleteAddTag.value.trim()) lifecycle.on_complete_add_tag = onCompleteAddTag.value.trim();
            var onFailureAddTag = formElement.querySelector('#on_failure_add_tag');
            if (onFailureAddTag && onFailureAddTag.value.trim()) lifecycle.on_failure_add_tag = onFailureAddTag.value.trim();

            // Build the final request body
            var body = {};
            if (Object.keys(trigger).length > 0) body.trigger = trigger;
            if (Object.keys(agent).length > 0) body.agent = agent;
            if (Object.keys(retry).length > 0) body.retry = retry;
            if (outcomes.length > 0) body.outcomes = outcomes;
            if (Object.keys(lifecycle).length > 0) body.lifecycle = lifecycle;

            // Submit via fetch for proper response handling
            fetch('/api/orchestrations/' + encodeURIComponent(name), {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(function(response) {
                return response.json().then(function(data) {
                    return { status: response.status, data: data };
                });
            }).then(function(result) {
                if (result.status >= 200 && result.status < 300 && result.data.success) {
                    showToast('success', 'Orchestration \'' + name + '\' updated successfully');
                    // Reload the detail view to show updated values
                    var detailContainer = formElement.closest('.orchestration-detail');
                    if (detailContainer) {
                        htmx.ajax('GET', '/partials/orchestration_detail/' + encodeURIComponent(name), {
                            target: detailContainer,
                            swap: 'outerHTML'
                        });
                    }
                } else if (result.status === 422) {
                    showToast('error', result.data.detail || 'Validation error');
                } else if (result.status === 429) {
                    showToast('warning', 'Rate limit exceeded. Please wait before trying again.');
                } else {
                    showToast('error', result.data.detail || 'Failed to update orchestration');
                }
            }).catch(function(error) {
                console.error('submitOrchestrationEdit: fetch error:', error);
                showToast('error', 'Network error while updating orchestration');
            });
        }
        /**
         * Submit an orchestration create form via the POST API endpoint.
         * Collects form fields, builds nested JSON matching OrchestrationCreateRequest,
         * and submits via fetch. Shows toast on result.
         * @param {HTMLFormElement} formElement - The form element to collect data from
         */
        function submitOrchestrationCreate(formElement) {
            if (!formElement) {
                console.error('submitOrchestrationCreate: formElement is null');
                return;
            }

            // Helper to split comma-separated or newline-separated values into an array
            function splitList(value, separator) {
                if (!value || !value.trim()) return [];
                var sep = separator || ',';
                return value.split(sep === '\n' ? /\r?\n/ : sep)
                    .map(function(s) { return s.trim(); })
                    .filter(function(s) { return s.length > 0; });
            }

            // Get orchestration name (required)
            var nameInput = formElement.querySelector('#create_name');
            if (!nameInput || !nameInput.value.trim()) {
                showToast('error', 'Orchestration name is required');
                return;
            }
            var name = nameInput.value.trim();

            // Get target file (required)
            var targetFileSelector = formElement.querySelector('#target_file_selector');
            var newFileNameInput = formElement.querySelector('#new_file_name');
            var targetFile = '';

            if (!targetFileSelector || !targetFileSelector.value) {
                showToast('error', 'Target file must be selected');
                return;
            }

            if (targetFileSelector.value === '__new__') {
                if (!newFileNameInput || !newFileNameInput.value.trim()) {
                    showToast('error', 'New file name is required');
                    return;
                }
                targetFile = newFileNameInput.value.trim();
            } else {
                targetFile = targetFileSelector.value;
            }

            // Build request body starting with required fields
            var body = {
                name: name,
                target_file: targetFile
            };

            // Add enabled field
            var enabledInput = formElement.querySelector('#create_enabled');
            if (enabledInput) {
                body.enabled = enabledInput.checked;
            }

            // Add max_concurrent if provided
            var maxConcurrent = formElement.querySelector('#create_max_concurrent');
            if (maxConcurrent && maxConcurrent.value) {
                body.max_concurrent = parseInt(maxConcurrent.value, 10);
            }

            // Build the trigger section
            var triggerSource = formElement.querySelector('input[name="trigger_source"]:checked');
            var trigger = {};
            if (triggerSource) {
                trigger.source = triggerSource.value;
                if (triggerSource.value === 'jira') {
                    var project = formElement.querySelector('#jira_project');
                    if (project && project.value.trim()) trigger.project = project.value.trim();
                    var jqlFilter = formElement.querySelector('#jira_jql_filter');
                    if (jqlFilter && jqlFilter.value.trim()) trigger.jql_filter = jqlFilter.value.trim();
                    var tags = formElement.querySelector('#jira_tags');
                    if (tags && tags.value.trim()) trigger.tags = splitList(tags.value);
                } else {
                    var projNum = formElement.querySelector('#github_project_number');
                    if (projNum && projNum.value) trigger.project_number = parseInt(projNum.value, 10);
                    var projScope = formElement.querySelector('input[name="github_project_scope"]:checked');
                    if (projScope) trigger.project_scope = projScope.value;
                    var projOwner = formElement.querySelector('#github_project_owner');
                    if (projOwner && projOwner.value.trim()) trigger.project_owner = projOwner.value.trim();
                    var projFilter = formElement.querySelector('#github_project_filter');
                    if (projFilter && projFilter.value.trim()) trigger.project_filter = projFilter.value.trim();
                    var labels = formElement.querySelector('#github_labels');
                    if (labels && labels.value.trim()) trigger.labels = splitList(labels.value);
                }
            }
            if (Object.keys(trigger).length > 0) body.trigger = trigger;

            // Build the agent section
            var agent = {};
            var agentType = formElement.querySelector('#agent_type');
            if (agentType && agentType.value) agent.agent_type = agentType.value;
            var cursorMode = formElement.querySelector('#cursor_mode');
            if (cursorMode && agentType && agentType.value === 'cursor') {
                agent.cursor_mode = cursorMode.value;
            }
            var model = formElement.querySelector('#model');
            if (model && model.value.trim()) agent.model = model.value.trim();
            var timeout = formElement.querySelector('#timeout_seconds');
            if (timeout && timeout.value) agent.timeout_seconds = parseInt(timeout.value, 10);
            var prompt = formElement.querySelector('#prompt');
            if (prompt && prompt.value.trim()) agent.prompt = prompt.value;

            // Build GitHub context sub-object
            var ghHost = formElement.querySelector('#github_host');
            var ghOrg = formElement.querySelector('#github_org');
            var ghRepo = formElement.querySelector('#github_repo');
            var ghBranch = formElement.querySelector('#github_branch');
            var ghCreateBranch = formElement.querySelector('#github_create_branch');
            var ghBaseBranch = formElement.querySelector('#github_base_branch');
            var github = {};
            var hasGithub = false;
            if (ghHost && ghHost.value.trim()) { github.host = ghHost.value.trim(); hasGithub = true; }
            if (ghOrg && ghOrg.value.trim()) { github.org = ghOrg.value.trim(); hasGithub = true; }
            if (ghRepo && ghRepo.value.trim()) { github.repo = ghRepo.value.trim(); hasGithub = true; }
            if (ghBranch && ghBranch.value.trim()) { github.branch = ghBranch.value.trim(); hasGithub = true; }
            if (ghCreateBranch) { github.create_branch = ghCreateBranch.checked; hasGithub = true; }
            if (ghBaseBranch && ghBaseBranch.value.trim()) { github.base_branch = ghBaseBranch.value.trim(); hasGithub = true; }
            if (hasGithub) agent.github = github;

            if (Object.keys(agent).length > 0) body.agent = agent;

            // Build the retry section
            var retry = {};
            var maxAttempts = formElement.querySelector('#max_attempts');
            if (maxAttempts && maxAttempts.value) retry.max_attempts = parseInt(maxAttempts.value, 10);
            var successPatterns = formElement.querySelector('#success_patterns');
            if (successPatterns && successPatterns.value.trim()) retry.success_patterns = splitList(successPatterns.value, '\n');
            var failurePatterns = formElement.querySelector('#failure_patterns');
            if (failurePatterns && failurePatterns.value.trim()) retry.failure_patterns = splitList(failurePatterns.value, '\n');
            var defaultStatus = formElement.querySelector('input[name="default_status"]:checked');
            if (defaultStatus) retry.default_status = defaultStatus.value;
            var defaultOutcome = formElement.querySelector('#default_outcome');
            if (defaultOutcome && defaultOutcome.value.trim()) retry.default_outcome = defaultOutcome.value.trim();
            if (Object.keys(retry).length > 0) body.retry = retry;

            // Build the outcomes section
            var outcomeRows = formElement.querySelectorAll('.outcome-row');
            var outcomes = [];
            outcomeRows.forEach(function(row) {
                var outName = row.querySelector('input[name="outcome_name"]');
                var outPatterns = row.querySelector('textarea[name="outcome_patterns"]');
                var outAddTag = row.querySelector('input[name="outcome_add_tag"]');
                if (outName && outName.value.trim()) {
                    var outcome = { name: outName.value.trim() };
                    if (outPatterns && outPatterns.value.trim()) outcome.patterns = splitList(outPatterns.value, '\n');
                    if (outAddTag && outAddTag.value.trim()) outcome.add_tag = outAddTag.value.trim();
                    outcomes.push(outcome);
                }
            });
            if (outcomes.length > 0) body.outcomes = outcomes;

            // Build the lifecycle section
            var lifecycle = {};
            var onStartAddTag = formElement.querySelector('#on_start_add_tag');
            if (onStartAddTag && onStartAddTag.value.trim()) lifecycle.on_start_add_tag = onStartAddTag.value.trim();
            var onCompleteRemoveTag = formElement.querySelector('#on_complete_remove_tag');
            if (onCompleteRemoveTag && onCompleteRemoveTag.value.trim()) lifecycle.on_complete_remove_tag = onCompleteRemoveTag.value.trim();
            var onCompleteAddTag = formElement.querySelector('#on_complete_add_tag');
            if (onCompleteAddTag && onCompleteAddTag.value.trim()) lifecycle.on_complete_add_tag = onCompleteAddTag.value.trim();
            var onFailureAddTag = formElement.querySelector('#on_failure_add_tag');
            if (onFailureAddTag && onFailureAddTag.value.trim()) lifecycle.on_failure_add_tag = onFailureAddTag.value.trim();
            if (Object.keys(lifecycle).length > 0) body.lifecycle = lifecycle;

            // Submit via fetch
            fetch('/api/orchestrations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            }).then(function(response) {
                return response.json().then(function(data) {
                    return { status: response.status, data: data };
                });
            }).then(function(result) {
                if (result.status >= 200 && result.status < 300 && result.data.success) {
                    showToast('success', 'Orchestration \'' + name + '\' created successfully');
                    // Hide the creation form
                    document.getElementById('create-form-container').style.display = 'none';
                    // Reload the orchestrations list (HTMX will auto-refresh on next poll)
                } else if (result.status === 422) {
                    showToast('error', result.data.detail || 'Validation error');
                } else if (result.status === 429) {
                    showToast('warning', 'Rate limit exceeded. Please wait before trying again.');
                } else {
                    showToast('error', result.data.detail || 'Failed to create orchestration');
                }
            }).catch(function(error) {
                console.error('submitOrchestrationCreate: fetch error:', error);
                showToast('error', 'Network error while creating orchestration');
            });
        }
    </script>
    {% block extra_head %}{% endblock %}
</head>
<body>
    <header>
        <h1>Developer Sentinel</h1>
        <nav>
            <a href="/" {% if request.url.path == "/" %}class="active"{% endif %}>Dashboard</a>
            <a href="/orchestrations" {% if request.url.path == "/orchestrations" %}class="active"{% endif %}>Orchestrations</a>
            <a href="/logs" {% if request.url.path == "/logs" %}class="active"{% endif %}>Logs</a>
            <a href="/metrics" {% if request.url.path == "/metrics" %}class="active"{% endif %}>Metrics</a>
        </nav>
    </header>
    <main>
        {% block content %}{% endblock %}
    </main>
</body>
</html>
